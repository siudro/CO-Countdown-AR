<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Noto+Sans+Arabic:wght@400;700;900&display=swap" rel="stylesheet" />

    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }

      video {
        position: fixed !important;
        top: 0 !important; left: 0 !important;
        width: 100% !important; height: 100% !important;
        object-fit: cover !important;
        z-index: 0 !important;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }

      canvas {
        position: fixed !important;
        top: 0 !important; left: 0 !important;
        width: 100% !important; height: 100% !important;
        z-index: 1 !important;
      }

      a-scene {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
      }

      #lang-switcher {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999;
        display: flex;
        align-items: center;
        gap: 6px;
        height: 36px;
      }

      .lang-btn {
        position: relative;
        padding: 0 20px;
        height: 100%;
        background: transparent;
        border: none;
        cursor: pointer;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        outline: none;
        font-size: 15px;
        font-weight: 700;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: rgba(238, 235, 224, 0.75);
        text-shadow: none;
        transition: color 0.25s, text-shadow 0.25s;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #btn-en { font-family: 'Share Tech Mono', monospace; }
      #btn-ar { font-family: 'Noto Sans Arabic', sans-serif; font-size: 17px; letter-spacing: 0.05em; }

      .lang-btn::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 0%;
        height: 1.5px;
        background: #F1684A;
        box-shadow: 0 0 8px #F1684A, 0 0 16px rgba(241,104,74,0.4);
        transition: width 0.3s ease;
        border-radius: 1px;
      }

      .lang-btn.active {
        color: #EEEBE0;
        text-shadow:
          0 0 10px rgba(241,104,74,0.75),
          0 0 24px rgba(241,104,74,0.35);
      }

      .lang-btn.active::after {
        width: 75%;
      }

      .lang-btn:active {
        color: #F1684A;
        text-shadow: 0 0 16px rgba(241,104,74,1);
      }
    </style>

    <script>

      /* ══════════════════════════════════════════════════════════════════
       *
       *
       *   new Date(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND)
       *   ⚠️  MONTH is 0-based: Jan=0, Feb=1, Mar=2 ... Dec=11
       *
       *   EXAMPLES:
       *     Sept 15 2025  6:00 PM  →  new Date(2025,  8, 15, 18,  0, 0)
       *     March  1 2026 10:30 AM →  new Date(2026,  2,  1, 10, 30, 0)
       *     Dec   31 2025 midnight →  new Date(2025, 11, 31,  0,  0, 0)
       *     June  20 2026  9:00 AM →  new Date(2026,  5, 20,  9,  0, 0)
       *
       */ const OPENING_DATE = new Date(2026, 3, 20, 9, 0, 0); /*
       *
       *   ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
       * ══════════════════════════════════════════════════════════════════ */

      let currentLang = 'en'; 

      const CORAL  = '#F1684A';
      const CORAL2 = '#F48870';
      const ORANGE = '#FCB451';
      const GREEN  = '#6FAD6C';
      const WHITE  = '#EEEBE0';

      function rgba(hex, a) {
        return `rgba(${parseInt(hex.slice(1,3),16)},${parseInt(hex.slice(3,5),16)},${parseInt(hex.slice(5,7),16)},${a})`;
      }

      function padEN(n) { return String(Math.floor(n)).padStart(2, '0'); }

      const AR_DIGITS = ['٠','١','٢','٣','٤','٥','٦','٧','٨','٩'];
      function padAR(n) {
        return String(Math.floor(n)).padStart(2,'0').split('').map(d => AR_DIGITS[+d]).join('');
      }

      function getTimeLeft() {
        const diff = Math.max(0, OPENING_DATE.getTime() - Date.now());
        return {
          days:    Math.floor(diff / 86400000),
          hours:   Math.floor((diff % 86400000) / 3600000),
          minutes: Math.floor((diff % 3600000)  / 60000),
          seconds: Math.floor((diff % 60000)    / 1000),
        };
      }

      document.fonts.load('900 80px "Noto Sans Arabic"');

      /* ── A-Frame component ── */
      AFRAME.registerComponent('countdown-display', {

        init: function () {
          this.canvas        = document.createElement('canvas');
          this.canvas.width  = 512;
          this.canvas.height = 768;
          this.ctx   = this.canvas.getContext('2d');
          this.frame = 0;
          this.tex   = new AFRAME.THREE.CanvasTexture(this.canvas);
          this.prev  = { days:-1, hours:-1, minutes:-1, seconds:-1 };
          this.flash = { days:0,  hours:0,  minutes:0,  seconds:0  };

          const applyTex = () => {
            const mesh = this.el.getObject3D('mesh');
            if (mesh) {
              mesh.material.map         = this.tex;
              mesh.material.transparent = true;
              mesh.material.alphaTest   = 0.01;
              mesh.material.needsUpdate = true;
            }
          };
          if (this.el.getObject3D('mesh')) applyTex();
          else this.el.addEventListener('object3dset', applyTex);
        },

        tick: function () {
          this.frame++;
          const t = getTimeLeft();
          ['days','hours','minutes','seconds'].forEach(k => {
            if (t[k] !== this.prev[k] && this.prev[k] !== -1) this.flash[k] = 30;
            if (this.flash[k] > 0) this.flash[k]--;
            this.prev[k] = t[k];
          });
          this.drawFrame(t);
          this.tex.needsUpdate = true;
        },

        drawFrame: function (t) {
          const ctx   = this.ctx;
          const frame = this.frame;
          const flash = this.flash;
          const lang  = currentLang;
          const W = 512, H = 768;

          ctx.clearRect(0, 0, W, H);

          const isAR    = lang === 'ar';
          const numFont = isAR
            ? `900 ${Math.round(H*0.15)}px "Noto Sans Arabic",sans-serif`
            : `bold ${Math.round(H*0.20)}px "Share Tech Mono",monospace`;
          const lblFont = isAR
            ? `700 ${Math.round(H*0.052)}px "Noto Sans Arabic",sans-serif`
            : `${Math.round(H*0.048)}px "Share Tech Mono",monospace`;
          const colonFont = isAR
            ? `900 ${Math.round(H*0.07)}px "Noto Sans Arabic",sans-serif`
            : `bold ${Math.round(H*0.07)}px "Share Tech Mono",monospace`;

          const units = isAR ? [
            { value: t.days,    label: 'أيام',  color: CORAL,  flash: '#FF9980', key: 'days'    },
            { value: t.hours,   label: 'ساعات', color: ORANGE, flash: '#FFE0A0', key: 'hours'   },
            { value: t.minutes, label: 'دقائق', color: GREEN,  flash: '#C0FFC0', key: 'minutes' },
            { value: t.seconds, label: 'ثواني', color: CORAL2, flash: '#FFD0C0', key: 'seconds' },
          ] : [
            { value: t.days,    label: 'DAYS', color: CORAL,  flash: '#FF9980', key: 'days'    },
            { value: t.hours,   label: 'HRS',  color: ORANGE, flash: '#FFE0A0', key: 'hours'   },
            { value: t.minutes, label: 'MIN',  color: GREEN,  flash: '#C0FFC0', key: 'minutes' },
            { value: t.seconds, label: 'SEC',  color: CORAL2, flash: '#FFD0C0', key: 'seconds' },
          ];

          /* ── Scan line ── */
          const scanY = (frame * 1.2) % H;
          const sg = ctx.createLinearGradient(0, scanY-6, 0, scanY+6);
          sg.addColorStop(0,   'rgba(241,104,74,0)');
          sg.addColorStop(0.5, 'rgba(241,104,74,0.10)');
          sg.addColorStop(1,   'rgba(241,104,74,0)');
          ctx.fillStyle = sg;
          ctx.fillRect(0, scanY-6, W, 12);

          /* ── Rising particles ── */
          ctx.save();
          for (let i = 0; i < 10; i++) {
            const seed  = (frame * 0.6 + i * 173.1) % 1000;
            const px    = (Math.sin(seed * 0.04) * 0.5 + 0.5) * W;
            const py    = H - ((frame * 0.7 + i * 95) % (H + 30));
            const alpha = Math.max(0, Math.sin(seed * 0.08) * 0.35);
            const r     = 1 + Math.abs(Math.sin(seed * 0.15)) * 2.5;
            ctx.globalAlpha = alpha;
            ctx.fillStyle   = [CORAL, ORANGE, GREEN][i % 3];
            ctx.shadowColor = [CORAL, ORANGE, GREEN][i % 3];
            ctx.shadowBlur  = 8;
            ctx.beginPath();
            ctx.arc(px, py, r, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

          /* ── Grid positions ── */
          const colL   = W * 0.27;
          const colR   = W * 0.73;
          const rowT   = H * 0.27;
          const rowB   = H * 0.73;
          const lblOff = H * 0.12;
          const midY   = H * 0.5;

          const positions = [
            { cx: colL, cy: rowT },
            { cx: colR, cy: rowT },
            { cx: colL, cy: rowB },
            { cx: colR, cy: rowB },
          ];

          /* ── Horizontal divider arms ── */
          const hGap = W * 0.09;
          ctx.save();
          ctx.shadowColor = ORANGE; ctx.shadowBlur = 8;
          const hGL = ctx.createLinearGradient(0, 0, W*0.5 - hGap, 0);
          hGL.addColorStop(0,   'rgba(252,180,81,0)');
          hGL.addColorStop(0.4, 'rgba(252,180,81,0.35)');
          hGL.addColorStop(1,   'rgba(252,180,81,0.6)');
          ctx.fillStyle = hGL;
          ctx.fillRect(0, midY - 1, W*0.5 - hGap, 2);
          const hGR = ctx.createLinearGradient(W*0.5 + hGap, 0, W, 0);
          hGR.addColorStop(0,   'rgba(252,180,81,0.6)');
          hGR.addColorStop(0.6, 'rgba(252,180,81,0.35)');
          hGR.addColorStop(1,   'rgba(252,180,81,0)');
          ctx.fillStyle = hGR;
          ctx.fillRect(W*0.5 + hGap, midY - 1, W*0.5 - hGap, 2);
          ctx.restore();

          /* ── Vertical divider arms ── */
          const vGap = H * 0.06;
          ctx.save();
          ctx.shadowColor = ORANGE; ctx.shadowBlur = 8;
          const vGT = ctx.createLinearGradient(0, 0, 0, H*0.5 - vGap);
          vGT.addColorStop(0,   'rgba(252,180,81,0)');
          vGT.addColorStop(0.4, 'rgba(252,180,81,0.25)');
          vGT.addColorStop(1,   'rgba(252,180,81,0.45)');
          ctx.fillStyle = vGT;
          ctx.fillRect(W*0.5 - 1, 0, 2, H*0.5 - vGap);
          const vGB = ctx.createLinearGradient(0, H*0.5 + vGap, 0, H);
          vGB.addColorStop(0,   'rgba(252,180,81,0.45)');
          vGB.addColorStop(0.6, 'rgba(252,180,81,0.25)');
          vGB.addColorStop(1,   'rgba(252,180,81,0)');
          ctx.fillStyle = vGB;
          ctx.fillRect(W*0.5 - 1, H*0.5 + vGap, 2, H*0.5 - vGap);
          ctx.restore();

          /* ── Blinking colons ── */
          const colonOn = Math.floor(frame / 26) % 2 === 0;
          [rowT, rowB].forEach(cy => {
            ctx.save();
            ctx.font         = colonFont;
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';
            ctx.globalAlpha  = colonOn ? 0.9 : 0.15;
            ctx.fillStyle    = ORANGE;
            ctx.shadowColor  = ORANGE;
            ctx.shadowBlur   = colonOn ? 18 : 0;
            ctx.fillText(':', W * 0.5, cy);
            ctx.restore();
          });

          /* ── Draw each unit ── */
          units.forEach((u, i) => {
            const { cx, cy } = positions[i];
            const fl    = flash[u.key];
            const flR   = fl / 30;
            const numStr = isAR ? padAR(u.value) : padEN(u.value);

            /* Halo burst */
            if (fl > 0) {
              const hR = (1 - flR) * W * 0.55;
              const hA = flR * 0.5;
              ctx.save();
              const halo = ctx.createRadialGradient(cx, cy, 0, cx, cy, hR);
              halo.addColorStop(0,   rgba(u.flash, hA));
              halo.addColorStop(0.5, rgba(u.flash, hA * 0.35));
              halo.addColorStop(1,   rgba(u.flash, 0));
              ctx.fillStyle = halo;
              ctx.fillRect(cx - hR, cy - hR, hR*2, hR*2);
              ctx.restore();
            }

            /* Ambient glow */
            const gR = W * 0.32 + flR * W * 0.12;
            const gA = 0.10 + flR * 0.20;
            ctx.save();
            const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, gR);
            glow.addColorStop(0,   rgba(u.color, gA));
            glow.addColorStop(0.6, rgba(u.color, gA * 0.3));
            glow.addColorStop(1,   rgba(u.color, 0));
            ctx.fillStyle = glow;
            ctx.fillRect(cx - gR, cy - gR, gR*2, gR*2);
            ctx.restore();

            /* pass glow */
            const extraG = flR * 45;
            ctx.save();
            ctx.font         = numFont;
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';
            ctx.direction    = 'ltr';
            ctx.shadowColor  = u.color; ctx.shadowBlur = 55 + extraG;
            ctx.fillStyle    = rgba(u.color, 0.22);
            ctx.fillText(numStr, cx, cy);
            ctx.shadowBlur   = 28 + extraG * 0.5;
            ctx.fillStyle    = rgba(u.color, 0.55);
            ctx.fillText(numStr, cx, cy);
            ctx.shadowBlur   = 10 + extraG * 0.25;
            ctx.fillStyle    = fl > 0 ? u.flash : WHITE;
            ctx.globalAlpha  = 0.97;
            ctx.fillText(numStr, cx, cy);
            ctx.restore();

            /* Label */
            const lblY = cy + lblOff;
            ctx.save();
            ctx.font         = lblFont;
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';
            ctx.direction    = isAR ? 'rtl' : 'ltr';
            ctx.fillStyle    = rgba(u.color, 0.70 + flR * 0.25);
            ctx.shadowColor  = u.color;
            ctx.shadowBlur   = 10 + flR * 14;
            ctx.fillText(u.label, cx, lblY);
            ctx.restore();

            /* Underline */
            const lblSz = isAR ? Math.round(H*0.052) : Math.round(H*0.048);
            const ulW   = lblSz * (isAR ? 3.2 : 2.8) + flR * 30;
            ctx.save();
            const ulG = ctx.createLinearGradient(cx - ulW/2, 0, cx + ulW/2, 0);
            ulG.addColorStop(0,   rgba(u.color, 0));
            ulG.addColorStop(0.5, rgba(u.color, 0.60 + flR * 0.35));
            ulG.addColorStop(1,   rgba(u.color, 0));
            ctx.fillStyle   = ulG;
            ctx.shadowColor = u.color;
            ctx.shadowBlur  = 6 + flR * 10;
            ctx.fillRect(cx - ulW/2, lblY + lblSz * 0.8, ulW, 1.5);
            ctx.restore();
          });

          /* ── Rare glitch ── */
          if (Math.random() < 0.03) {
            try {
              const gy = 20 + Math.random() * (H - 40);
              const id = ctx.getImageData(0, gy, W, 6 + Math.random() * 10);
              ctx.putImageData(id, (Math.random() - 0.5) * 16, gy);
            } catch(e) {}
          }
        }
      });

      /* ── Video enforcement ── */
      window.addEventListener('load', () => {
        const scene = document.querySelector('a-scene');
        scene.addEventListener('arReady', () => {
          const enforceVideo = () => {
            document.querySelectorAll('video').forEach(v => {
              v.style.cssText = `
                position: fixed !important;
                top: 0 !important; left: 0 !important;
                width: 100% !important; height: 100% !important;
                object-fit: cover !important;
                z-index: 0 !important;
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                pointer-events: none !important;
              `;
            });
          };
          enforceVideo();
          setInterval(enforceVideo, 500);
        });
      });

      function setLang(lang) {
        currentLang = lang;
        document.getElementById('btn-en').classList.toggle('active', lang === 'en');
        document.getElementById('btn-ar').classList.toggle('active', lang === 'ar');
        document.documentElement.lang = lang;
      }
    </script>
  </head>

  <body>

    <div id="lang-switcher">
      <button id="btn-en" class="lang-btn active" onclick="setLang('en')">En</button>
      <button id="btn-ar" class="lang-btn"        onclick="setLang('ar')">ع</button>
    </div>

    <a-scene
      mindar-image="imageTargetSrc: ./targets/targets.mind; autoStart: true;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-plane
          position="0 0 0.01"
          width="1.6"
          height="2.4"
          countdown-display
        ></a-plane>
      </a-entity>
    </a-scene>

  </body>
</html>
